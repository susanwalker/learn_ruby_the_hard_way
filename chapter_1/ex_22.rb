# Words and Symbols learned so far in this book:

# puts - writes onto the screen the code that was entered
# comments ignore a line, like the start of this line
# math symbols: +, -, *, /, <, >, <=, >= floats ie. 0.0 more accurate decimal results
# string interpolation = #{} to refer to a variable or keep on same line
# prints does not add a line break, puts automatically does
# strings = "" or '' lines of text to specify
# \n line break, \ escape character
# use of #{} to first define variables, then refer to them, can combine with math
# %s to stand for a string, %d for a decimal, to stand for a variable
# string can be added + (concatenation)
# string interpolation can be nested
# <<PARAGRAPH -> PARAGRAPH to wrap lines of text
# \t to tab in a line
# gets.chomp() gets input from user, chomp to remove \n end character
# require uses existing resource libraries vs include to run the file
# ARGV and $0 to store the name of the function used together to take input and assign it
# STDIN removes first input being treated as file vs. only gets.chomp
# working with files, we can call file.read, file.open, file.close, etc.
# 'w' is needed to add as an argument so we can overwrite
# combination of ARGV/STDINgets.chomp to define, open, re-write and close a file
# re-naming input -> output and combined with file.open(filename, 'w') concepts we can copy to new file
# instead of ARGV, we can use defined methods -> def/end blocks
# methods are defined with the args passed into them, we can pass in args or combine with math
# can call on methods to run combinations, redefine and pass into another method
# IO::SEEK_SET to go back defined amount in a file
# f.read, f.readline
# current_line + 1 updated repeatedly con't to update current_line
# methods write out what is 'puts' but actually return the value defined inside
# the proof is that is to call on methods and combine them, the results will reflect what was returned

